<rss version="2.0">
    <channel>    
        <title>Влад Костянецкий</title>
        <description>Привет! Меня зовут Влад, я — разработчик приложений для бизнеса.</description>
        <language>ru</language>
        <link>https://kostyanetsky.ru</link>
        <lastBuildDate>Tue, 08 Jun 2021 17:12:05 +0700</lastBuildDate>
        
        <item>
            <title>Метаданные не найдены</title>
            <link>https://kostyanetsky.ru/notes/metadata-not-found/</link>
            <guid isPermaLink="false">note-metadata-not-found</guid>
            <pubDate>Tue, 08 Jun 2021 17:12:05 +0700</pubDate>
            <description><p class="measure-wide"><img alt="Метаданные не найдены" src="https://kostyanetsky.ru/notes/metadata-not-found/error-ru.png"/></p>
<p class="measure-wide">Думаю, с этой ошибкой мало кто сталкивался. Для этого, во-первых, нужно работать со встроенной в платформу историей данных, а она не больно-то популярна: кто-то привязан к БСП (она пока использует привычное всем версионирование на регистрах сведений), кому-то не нравится реализация — там и правда не всё гладко с точки зрения производительности.</p>
<p class="measure-wide">Во-вторых, нужно ляпнуть одну вполне конкретную ошибку: выключить историю данных для объекта метаданных, а потом грохнуть накопленные версии объектов до того, как новые изменения объекта перекочуют из буфера в основную таблицу.</p>
<p class="measure-wide">В двух словах о том, как это работает. По дефолту история данных выключена, и достаточно привилегированный пользователь может её включить для нужных ему объектов — констант, справочников, документов и так далее. После этого при изменении данных в этих объектах платформа будет фиксировать, что именно меняется. Делает она это в два этапа: сначала —  относительно быстрая запись в промежуточный буфер (таблицу _DataHistoryQueue0); потом, при вызове метода ОбновитьИсторию(), информация мигрирует в основное хранилище версий (таблицу _DataHistoryVersions).</p>
<p class="measure-wide">Обновление истории можно делать сразу при записи, но для экономии ресурсов его обычно выносят в регламентное задание. В итоге миграция данных из буфера в основную таблицу происходит с некоторой периодичностью: например, раз в пять минут. Так вот, если между изменением данных объекта и обновлением истории выключить историю данных измененного объекта и удалить его версии — метод ОбновитьИсторию() выкинет исключение: он попытается переместить изменения из буфера в основную таблицу, но не сможет привязать их к уже накопленным данным.</p>
<p class="measure-wide">Для наглядности — <a class="link blue dim bb" href="https://gist.github.com/vkostyanetsky/ca766fe281425953e0e2bbfe12fc70e2">рабочий код</a>, воспроизводящий проблему для справочника Items на платформе 8.3.17.1989. Можете подставить любой другой объект, с которым работает история данных — разницы нет. </p>
<p class="measure-wide"><strong>Как избежать этой ошибки?</strong> Ну, очевидно: метод ОбновитьИсторию() нужно вызывать непосредственно перед тем, как отключать историю для объекта. Лучше всего делать это в период, когда пользователи с системой не работают: есть риск, что между обновлением истории и её выключением вклинятся чьи-то транзакции, которые спровоцируют ту же проблему. Для гарантии можно использовать монопольный режим.</p>
<p class="measure-wide">Ещё в голову приходит исключительная блокировка на таблицу объекта, но документация не советует вызывать метод ОбновитьИсторию() внутри транзакций — так что тут я не уверен.</p>
<p class="measure-wide"><strong>Как исправить эту ошибку?</strong> Включите историю данных для проблемного объекта, обновите историю и выключите её обратно. Выйдите, так сказать, из класса и зайдите нормально.</p></description>
        </item>
        
        <item>
            <title>Скрипт для синхронизации c NAS</title>
            <link>https://kostyanetsky.ru/notes/rclone-abuser/</link>
            <guid isPermaLink="false">note-rclone-abuser</guid>
            <pubDate>Mon, 07 Jun 2021 19:04:48 +0700</pubDate>
            <description><p class="measure-wide">Выложил на GitHub <a class="link blue dim bb" href="https://github.com/vkostyanetsky/RCloneAbuser">скрипт</a> на Python, который я использую для синхронизации файлов между своим компьютером и домашним NAS'ом. У меня стоит Synology DS220j; с ним так-то идет целый вагон софта и в том числе утилита, которая умеет гонять файлы туда-сюда по расписанию. Однако сделана она, похоже, чисто для галочки: программа принялась глючить ещё на этапе настройки, после чего доверие к ней я потерял.</p>
<p class="measure-wide">В общем, какое-то время я помучался с решениями конкурентов и в итоге вернулся к привычному <a class="link blue dim bb" href="https://rclone.org">rclone</a>, с которым было всего две проблемы. Во-первых, нельзя нормально соединиться с SMB-шарой: да, логин и пароль можно сохранить в Windows и rclone будет их использовать, но они будут слетать при каждом удобном случае. Я вышел из положения, подключив шару как внешний диск.</p>
<p class="measure-wide">Во-вторых, файлов и папок для синхронизации у меня оказалось много: директория здесь, директория там, конфиг оттуда, профиль отсюда... Чтобы не плодить лапшу, я накатал простой скрипт, который берет из конфига источники и приемники, а потом для каждого вызывает rclone по одному и тому же шаблону.</p></description>
        </item>
        
        <item>
            <title>Как готовиться к 1С:Эксперту</title>
            <link>https://kostyanetsky.ru/notes/1c-expert/</link>
            <guid isPermaLink="false">note-1c-expert</guid>
            <pubDate>Tue, 25 May 2021 21:25:48 +0700</pubDate>
            <description><p class="measure-wide">В середине мая я сдал экзамен на статус эксперта в 1С по технологическим вопросам крупных внедрений. Подготовка вышла долгая, почти два года — так что я чертовски рад, что наконец-то справился.</p>
<p class="measure-wide">В сети есть море материала про этот экзамен и связанные с ним темы — начиная с <a class="link blue dim bb" href="https://uc1.1c.ru/course/podgotovka-k-1s-ekspertu-po-tehnologicheskim-voprosam-osnovnoj-kurs/">курса</a> Виктора Богачева и заканчивая, не знаю, релевантным <a class="link blue dim bb" href="https://t.me/OneC_Expert">чатом</a> в Телеграме. То есть вопрос из заголовка заметки обычно не стоит. Но я хочу написать о паре психологических заморочек, к которым лучше быть готовым заранее и о которых обычно не вспоминают.</p>
<h2>Нехватка дофамина</h2>
<p class="measure-wide">Этот экзамен — сложный. Подготовка может затянуться, как и сдача: очень вероятно, что потребуется несколько попыток. Я справился со второго раза, но у людей выходит по-всякому — среди моих знакомых есть те, кто сдал с третьего, пятого или даже восьмого захода.</p>
<p class="measure-wide">То есть может получиться так, что вы раз за разом будете сильно вкладываться, а результата не получать. Через какое-то время ваш мозг решит, что этой задачи надо избегать: какая-то она провальная, бесполезная и вызывает неприятные ощущения. Как это повлияет на конечную цель, догадаться легко.</p>
<p class="measure-wide">Поэтому к подготовке лучше подходить как к долгому и рискованному проекту: разбавлять её короткими и, главное, успешными задачами. Для мозга нет существенной разницы между большим и маленьким успехом, и вернуться к основному проекту будет проще.</p>
<p class="measure-wide">Например, я для отвлечения катал скрипты для домашней автоматизации — генератор статики для этого сайта, органайзер на текстовых файлах, обвязку для домашнего NAS'а и тому подобные штуки, до которых раньше никак руки не доходили. Подойдут любые задачи — включая те, что с айтишечкой вообще не связаны. Почистить слив в ванной? Отличная идея!</p>
<h2>Нехватка памяти</h2>
<p class="measure-wide">Если вы не работаете с проблемами производительности 1С каждый день, этот экзамен — очень ресурсоемкий контекст. Вы будете держать в голове массу вспомогательных данных, которые обычно берете из документации: флаги трассировки и имена динамических представлений Microsoft SQL Server, настройки PostgreSQL и рекомендации по их заполнению, перечень стандартных индексов платформы и так далее, и тому подобное. Во-о-от такенная куча информации! <em>(показывает руками, какая)</em></p>
<p class="measure-wide">Между тем, наш мозг при работе с большими объёмами данных порой крепко напоминает СУБД, работающую с переполненным буферным кэшем. Другими словами: всё, что не нужно в данный момент, будет выгружено из памяти. Готовьтесь забывать самые неожиданные вещи: номер своей квартиры, кличку соседской собаки, день рождения жены — и это ещё не самые диковатые последствия. Я, пока готовился, чуствовал сильное духовное родство с Джонни Мнемоником — персонажем старого-престарого киберпанка, который загрузил себе в мозги столько данных, что чуть не отбросил коньки :-)</p>
<p class="measure-wide"><img alt="Не надо так" src="https://kostyanetsky.ru/notes/1c-expert/dont-do-it.jpg"/></p>
<p class="measure-wide">Выхода тут мне видится два, оба довольно очевидные.</p>
<p class="measure-wide">Во-первых, старайтесь набивать руку. Сложные технические детали запоминаются в сто раз легче, когда у тебя перед глазами тут же встает интерфейс программы, на которой ты их проверял.</p>
<p class="measure-wide">Во-вторых — старайтесь строить ассоциативные цепочки для наиболее заковыристых штук. Взять, например, баш! Название утилиты sed проще запомнить, если знать, что это сокращение от Stream EDitor. Утилита cat называется так, потому что concatenate, а не потому что кошка, но если вам проще запомнить второй вариант — так и делайте. Почему нет?</p>
<p class="measure-wide">Или, скажем, маркер последовательности байтов. \xef\xbb\xbf, ага. Его я намертво запомнил — только не смейтесь — через абсолютно иррелевантную фразу «Elf Friend BB Best Fight». Понятия не имею, почему моя голова работает через <s>такую жо</s> такие заковыристые интерфейсы, но жаловаться я не собираюсь. Главное — отыскать их!</p></description>
        </item>
        
        <item>
            <title>Новый скрипт поиска долгих запросов</title>
            <link>https://kostyanetsky.ru/notes/longest-queries-v2/</link>
            <guid isPermaLink="false">note-longest-queries-v2</guid>
            <pubDate>Mon, 26 Apr 2021 19:24:00 +0700</pubDate>
            <description><p class="measure-wide">Обновил <a class="link blue dim bb" href="https://github.com/vkostyanetsky/ScriptsFor1C/blob/master/Технологический журнал/LongestQueries.sh">скрипт</a> поиска долгих запросов в технологическом журнале платформы. Ранняя версия содержала серьёзный косяк: она старательно группировала DBMSSQL по Sql и Content, но игнорировала случаи, в которых поле Sql отсутствовало (для DBMSSQL это не то чтобы норма, но встречается).</p>
<p class="measure-wide">Ну и код слегка причесал, чтобы два раза не вставать: добавил разметку и комментарии, а часть логики gawk'а вынес из основного тела в функции. Да, скрипт стал смотреться длиннее, чем он есть на самом деле, зато читать его стало куда проще.</p>
<p class="measure-wide">Мне вообще, по-чеснаку, непонятна причина, по которой ветераны баша трамбуют всю логику в две-три строки: язык и так-то не блещет читаемостью (в телеграм-канале Никиты Прокопова есть <a class="link blue dim bb" href="https://t.me/nikitonsky_pub/55">отличный текст</a> на эту тему), а при виде страницы конвейеров без единого перевода строки вообще хочется молча выйти в окно.</p></description>
        </item>
        
        <item>
            <title>Пучок скриптов</title>
            <link>https://kostyanetsky.ru/notes/bunch-of-scrips/</link>
            <guid isPermaLink="false">note-bunch-of-scrips</guid>
            <pubDate>Sat, 24 Apr 2021 10:00:00 +0700</pubDate>
            <description><p class="measure-wide">Выложил на GitHub ещё несколько скриптов для разбора технологического журнала платформы, которые написал за последнее время:</p>
<ul class="measure-wide">
<li><a class="link blue dim bb" href="https://github.com/vkostyanetsky/ScriptsFor1C/blob/master/Технологический журнал/FrequentEvents.sh">Частотные события</a>. Группирует события по наименованию, считает количество воспроизведений для каждого и выводит в порядке убывания — от наиболее частотного к наименее частотному. Практического применения у этого скрипта, скорее, нет; просто фиксировал для себя, какой процесс кластера какие события пишет.</li>
<li><a class="link blue dim bb" href="https://github.com/vkostyanetsky/ScriptsFor1C/blob/master/Технологический журнал/ExceptionDescriptions.sh">Описания исключений</a>. Группирует EXCP по полю Name; для каждого наименования выводит варианты значений поля Description, которые были у исключений с таким наименованием. С помощью этого скрипта можно составить примерную картину: какие исключения действительно проблема, а какие — просто белый шум, который можно игнорировать и, например, закинуть в фильтры Кибаны.</li>
<li><a class="link blue dim bb" href="https://github.com/vkostyanetsky/ScriptsFor1C/blob/master/Технологический журнал/LocksByConnectIDAndRegions.sh">Блокировки по ID соединения и области</a>. Удобен для поиска виновника таймаута на управляемых блокировках: скрипт выгребает из ТЖ все TLOCK'и по конкретной области от конкретного соединения, а потом выстраивает их в хронологическом порядке.</li>
</ul></description>
        </item>
        
        <item>
            <title>SKUUUID в своем глазу</title>
            <link>https://kostyanetsky.ru/notes/skuuuid/</link>
            <guid isPermaLink="false">note-skuuuid</guid>
            <pubDate>Mon, 22 Feb 2021 17:11:53 +0700</pubDate>
            <description><p class="measure-wide">Пару недель назад Александр Кунташов у себя на канале <a class="link blue dim bb" href="https://t.me/kuntashov_devnotes/479">запостил</a> забавный скрин перечисления из Библиотеки Электронных Документов, создателей которого откровенно манили длинные аббревиатуры. Я бодро острил на тему родства ИППДОИПУПДУКД'а и московского ГНУВНИВИПФИТ'а, а потом увидел в собственном коде вот эту красотку:</p>
<p class="measure-wide"><img alt="SKUUUID" src="https://kostyanetsky.ru/notes/skuuuid/skuuuid.png"/></p>
<p class="measure-wide">Ещё не вполне рука маэстро, конечно, но движение определенно в том же направлении. Вспомнилась притча про сучок в чужом глазу и суковатое бревно — в своём :-)</p></description>
        </item>
        
        <item>
            <title>Проблема с литералом даты при пересчете итогов</title>
            <link>https://kostyanetsky.ru/notes/date-literal-exceeds-3999/</link>
            <guid isPermaLink="false">note-date-literal-exceeds-3999</guid>
            <pubDate>Sat, 06 Feb 2021 19:13:53 +0700</pubDate>
            <description><p class="measure-wide">Итак, в ходе рутинного пересчета итогов из Конфигуратора мы неожиданно получили ошибку «номер года в литерале типа дата превышает 3999». Это значит, где-то в базе есть (или пытается появиться) дата больше, чем предельно допустимая с точки зрения 1С (31.12.3999 23:59:59).</p>
<p class="measure-wide"><img alt="Исключение" src="https://kostyanetsky.ru/notes/date-literal-exceeds-3999/excp.png"/></p>
<p class="measure-wide">Ладно, что с этим делать?</p>
<p class="measure-wide">Главное — выйти на конкретную таблицу с проблемными датами. Ошибка возникла при пересчете итогов, так что очевидно: искать нужно в регистрах. Открываем стандартную обработку управления итогами, делаем пересчет и <a class="link blue dim bb" href="https://kostyanetsky.ru/notes/date-literal-exceeds-3999/totals.png">получаем</a> имя регистра, на котором спотыкается платформа.</p>
<p class="measure-wide">Другой, более методологически правильный подход — настроить сбор ТЖ (SDBL, EXCP и EXCPCNTX) и получить примерно <a class="link blue dim bb" href="https://kostyanetsky.ru/notes/date-literal-exceeds-3999/excp.log">такой</a> лог. Ищем в нём событие EXCP (исключение), а непосредственно перед ним — событие SDBL (SQL-запрос в терминах платформы). Этот запрос — причина сбоя; в его тексте видим имя нужной нам таблицы (AccumRgTn11530). Имя объекта конфигурации для неё можно вытащить любой обработкой, построенной на методе ПолучитьСтруктуруХраненияБазыДанных().</p>
<p class="measure-wide">В общем, так или иначе мы получим имя регистра. Открываем его форму и простой сортировкой по периоду выходим на <a class="link blue dim bb" href="https://kostyanetsky.ru/notes/date-literal-exceeds-3999/entries.png">проблемные движения</a>. Нужно проанализировать документы, которые их сделали, устранить причину ошибки и перепровести документы. Если после этого проблема с пересчетом останется — это либо не единственная таблица с проблемными датами (ищем дальше), либо эти даты успели засесть где-то ещё, кроме таблицы движений.</p>
<p class="measure-wide">Например, у меня был случай, когда после исправления движений записи с некорректными датами сохранялись в таблице оборотов. Средствами платформы их удалить было нельзя, но размер базы позволял играться с реструктуризацией. Я выкинул следующий финт: отключил признак «Использование в итогах» для всех измерений регистра и применил изменения; потом вернул признак на место и пересчитал итоги. В итоге таблица оборотов регистра была физически удалена, а потом создана и наполнена заново — уже без дат на много веков вперёд.</p>
<p class="measure-wide">В крайнем случае можно было удалить проблемные записи с помощью прямых SQL-запросов (DELETE или даже TRUNCATE). Но это, во-первых, нарушает лицензионное соглашение с разработчиками платформы, а во вторых — опасно (по неосторожности можно удалить что-то важное и не заметить). Так что не советую, э-э, повторять в домашних условиях :-)</p></description>
        </item>
        
        <item>
            <title>Определение видимости объекта</title>
            <link>https://kostyanetsky.ru/notes/do-you-see-it/</link>
            <guid isPermaLink="false">note-do-you-see-it</guid>
            <pubDate>Sun, 17 Jan 2021 12:34:45 +0700</pubDate>
            <description><p class="measure-wide">В платформе сразу несколько механик решает, видит пользователь некий объект метаданных или нет. Одна из них — функциональные опции. Если вы раньше не имели с ними дела, в двух словах дела обстоят так: объект можно добавить в состав опции, которая внутри конкретной базы может как быть активной (и видимой пользователям), так и неактивной (и, соответственно, скрытой). Объект можно засунуть в несколько опций сразу (и тогда он отображается, если активна хотя бы одна из них) или не включать вообще никуда (и тогда пользователи его видят в любом случае).</p>
<p class="measure-wide">Так вот, помню, лет пять назад я искал способ понять из кода — видит пользователь объект или нет? Чисто с точки зрения функциональных опций. Тогда я почему-то не нашел решения, а ведь оно до смешного простое; вот, например, <a class="link blue dim bb" href="https://gist.github.com/vkostyanetsky/a6c0525c38a8231f37a676ec240d657a">функция</a> ровно для этого. Логика:</p>
<ol class="measure-wide">
<li>Перебираем опции и ищем объект в составе каждой из них.</li>
<li>Если объект есть в составе опции, проверяем: опция активна? Если да — значит, пользователь видит объект.</li>
<li>Если объект не включен ни в одну опцию — тоже видит.</li>
</ol>
<p class="measure-wide">Конечно, результаты такого анализа как минимум нужно кэшировать (хотя бы из-за запроса в цикле), но в остальном он вполне адекватен. Никак не возьму в толк, почему я тогда не написал что-то похожее? Ох, надеюсь, спустя следующие пять лет мои нынешние занозы в заднице тоже будут отлетать на раз-два-три.</p></description>
        </item>
        
        <item>
            <title>Рекурсивный поиск по файлам</title>
            <link>https://kostyanetsky.ru/notes/recursive-search/</link>
            <guid isPermaLink="false">note-recursive-search</guid>
            <pubDate>Thu, 14 Jan 2021 10:15:16 +0700</pubDate>
            <description><p class="measure-wide">Время назад я <a class="link blue dim bb" href="https://kostyanetsky.ru/notes/vulnerabilities/">примеривался</a> к поискам уязвимостей в коде скриптами на bash (звучит грозно, но это просто рекурсивный поиск текста с помощью регулярных выражений). Скрипты-то я тогда написал, но, как сегодня понял — несколько... Ректально, кхм. Для решения хватает одного egrep! То есть из связки find, xargs и egrep можно выкинуть два компонента из трех.</p>
<p class="measure-wide">Например, сегодня у нас возникла проблема: конфигурация перестала собираться в последнем релизе EDT. Подозрение пало на битые GUID — ссылки на объекты метаданных, удаленные из конфигурации. Платформа не всегда справляется с их вычисткой после того, как удалит сами объекты; я уже пару раз писал про это (например, <a class="link blue dim bb" href="https://kostyanetsky.ru/notes/designer-error-investigation/">здесь</a> или <a class="link blue dim bb" href="https://kostyanetsky.ru/notes/unresolved-gopher/">вот тут</a>).</p>
<p class="measure-wide">В общем, мы решили порыться в выгрузке конфигурации — найти GUID'ы и оценить, все ли они находятся там, где положено. Общее решение — одна-единственная команда:</p>
<pre><code>egrep -rn '.{8}-.{4}-.{4}-.{4}-.{12}' dump
</code></pre>
<p class="measure-wide">Ключ r включает рекурсивный поиск, ключ n — заставляет утилиту пристегнуть к найденной строке не только имя файла, в котором найдена строка, но и номер самой строки. Последний параметр, dump — имя директории, где нужно искать.</p>
<p class="measure-wide">Регулярку можно сделать точнее, но и такой за глаза хватает. Что до ложных срабатываний (то есть GUID, которые не являются битыми ссылками) — их легко отсеять через пайп. Например, скрипт ниже не будет выводить строки с GUID, в которых есть подстрока «uuid»:</p>
<pre><code>egrep -rn '.{8}-.{4}-.{4}-.{4}-.{12}' dump | grep -v 'uuid'
</code></pre></description>
        </item>
        
        <item>
            <title>Старый добрый DATETIME</title>
            <link>https://kostyanetsky.ru/notes/old-but-gold/</link>
            <guid isPermaLink="false">note-old-but-gold</guid>
            <pubDate>Wed, 11 Nov 2020 17:00:50 +0700</pubDate>
            <description><p class="measure-wide">Порылся в сети по поводу типов дат в MS SQL Server и в целом вопроса «почему 1С до сих пор носится со своим смещением» больше не имею. Люди пишут о целой пачке проблем с DATETIME2:</p>
<ol class="measure-wide">
<li>Недоступна базовая математика. Без дополнительных финтов ушами не выйдет посчитать разницу между двумя датами, прибавить к дате день и так далее.</li>
<li>Стандартные функции по-прежнему возвращают старый добрый DATETIME (например, DATEADD). Если данные хранятся в DATETIME2 — потребуется конвертация.</li>
<li>Поля с этим типом <a class="link blue dim bb" href="https://sqlperformance.com/2016/04/sql-performance/surprises-dateadd">неважно</a> индексируются, так как каждое значение DATETIME2 хранится задом наперед (сначала время, потом дата). В итоге СУБД промахивается с оценкой количества строк, которое может вернуть запрос, и строит для него неэффективный план выполнения.</li>
</ol>
<p class="measure-wide">Подробнее о всем этом можно прочитать на <a class="link blue dim bb" href="https://towardsdatascience.com/datetime2-why-you-should-not-use-it-70e50ae2bab9">Towards Data Science</a> или, например, на <a class="link blue dim bb" href="https://www.sqlservercentral.com/forums/topic/why-do-some-dbas-avoid-datetime2">SQL Server Central</a>.</p></description>
        </item>
        
    </channel>
</rss>